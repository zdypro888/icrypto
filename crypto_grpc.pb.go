// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.19.4
// source: crypto.proto

package icrypto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CryptServiceClient is the client API for CryptService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CryptServiceClient interface {
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error)
	Finalize(ctx context.Context, in *FinalizeRequest, opts ...grpc.CallOption) (*FinalizeResponse, error)
	Activation(ctx context.Context, in *ActivationRequest, opts ...grpc.CallOption) (*ActivationResponse, error)
	ActivationKeyData(ctx context.Context, in *ActivationKeyDataRequest, opts ...grpc.CallOption) (*ActivationKeyDataResponse, error)
	ActivationDRMHandshake(ctx context.Context, in *ActivationDRMHandshakeRequest, opts ...grpc.CallOption) (*ActivationDRMHandshakeResponse, error)
	ActivationDRMHandshakeInfo(ctx context.Context, in *ActivationDRMHandshakeInfoRequest, opts ...grpc.CallOption) (*ActivationDRMHandshakeInfoResponse, error)
	ADIStartProvisioning(ctx context.Context, in *ADIStartProvisioningRequest, opts ...grpc.CallOption) (*ADIStartProvisioningResponse, error)
	ADIEndProvisioning(ctx context.Context, in *ADIEndProvisioningRequest, opts ...grpc.CallOption) (*ADIEndProvisioningResponse, error)
	AbsintheHello(ctx context.Context, in *AbsintheHelloRequest, opts ...grpc.CallOption) (*AbsintheHelloResponse, error)
	AbsintheAddOption(ctx context.Context, in *AbsintheAddOptionRequest, opts ...grpc.CallOption) (*AbsintheAddOptionResponse, error)
	AbsintheAtivateSession(ctx context.Context, in *AbsintheAtivateSessionRequest, opts ...grpc.CallOption) (*AbsintheAtivateSessionResponse, error)
	AbsintheSignData(ctx context.Context, in *AbsintheSignDataRequest, opts ...grpc.CallOption) (*AbsintheSignDataResponse, error)
	IndentitySession(ctx context.Context, in *IndentitySessionRequest, opts ...grpc.CallOption) (*IndentitySessionResponse, error)
	IndentityValidation(ctx context.Context, in *IndentityValidationRequest, opts ...grpc.CallOption) (*IndentityValidationResponse, error)
}

type cryptServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewCryptServiceClient(cc grpc.ClientConnInterface) CryptServiceClient {
	return &cryptServiceClient{cc}
}

func (c *cryptServiceClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error) {
	out := new(InitializeResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/Initialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) Finalize(ctx context.Context, in *FinalizeRequest, opts ...grpc.CallOption) (*FinalizeResponse, error) {
	out := new(FinalizeResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/Finalize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) Activation(ctx context.Context, in *ActivationRequest, opts ...grpc.CallOption) (*ActivationResponse, error) {
	out := new(ActivationResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/Activation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) ActivationKeyData(ctx context.Context, in *ActivationKeyDataRequest, opts ...grpc.CallOption) (*ActivationKeyDataResponse, error) {
	out := new(ActivationKeyDataResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/ActivationKeyData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) ActivationDRMHandshake(ctx context.Context, in *ActivationDRMHandshakeRequest, opts ...grpc.CallOption) (*ActivationDRMHandshakeResponse, error) {
	out := new(ActivationDRMHandshakeResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/ActivationDRMHandshake", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) ActivationDRMHandshakeInfo(ctx context.Context, in *ActivationDRMHandshakeInfoRequest, opts ...grpc.CallOption) (*ActivationDRMHandshakeInfoResponse, error) {
	out := new(ActivationDRMHandshakeInfoResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/ActivationDRMHandshakeInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) ADIStartProvisioning(ctx context.Context, in *ADIStartProvisioningRequest, opts ...grpc.CallOption) (*ADIStartProvisioningResponse, error) {
	out := new(ADIStartProvisioningResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/ADIStartProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) ADIEndProvisioning(ctx context.Context, in *ADIEndProvisioningRequest, opts ...grpc.CallOption) (*ADIEndProvisioningResponse, error) {
	out := new(ADIEndProvisioningResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/ADIEndProvisioning", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) AbsintheHello(ctx context.Context, in *AbsintheHelloRequest, opts ...grpc.CallOption) (*AbsintheHelloResponse, error) {
	out := new(AbsintheHelloResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/AbsintheHello", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) AbsintheAddOption(ctx context.Context, in *AbsintheAddOptionRequest, opts ...grpc.CallOption) (*AbsintheAddOptionResponse, error) {
	out := new(AbsintheAddOptionResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/AbsintheAddOption", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) AbsintheAtivateSession(ctx context.Context, in *AbsintheAtivateSessionRequest, opts ...grpc.CallOption) (*AbsintheAtivateSessionResponse, error) {
	out := new(AbsintheAtivateSessionResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/AbsintheAtivateSession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) AbsintheSignData(ctx context.Context, in *AbsintheSignDataRequest, opts ...grpc.CallOption) (*AbsintheSignDataResponse, error) {
	out := new(AbsintheSignDataResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/AbsintheSignData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) IndentitySession(ctx context.Context, in *IndentitySessionRequest, opts ...grpc.CallOption) (*IndentitySessionResponse, error) {
	out := new(IndentitySessionResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/IndentitySession", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cryptServiceClient) IndentityValidation(ctx context.Context, in *IndentityValidationRequest, opts ...grpc.CallOption) (*IndentityValidationResponse, error) {
	out := new(IndentityValidationResponse)
	err := c.cc.Invoke(ctx, "/icrypto.CryptService/IndentityValidation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CryptServiceServer is the server API for CryptService service.
// All implementations must embed UnimplementedCryptServiceServer
// for forward compatibility
type CryptServiceServer interface {
	Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error)
	Finalize(context.Context, *FinalizeRequest) (*FinalizeResponse, error)
	Activation(context.Context, *ActivationRequest) (*ActivationResponse, error)
	ActivationKeyData(context.Context, *ActivationKeyDataRequest) (*ActivationKeyDataResponse, error)
	ActivationDRMHandshake(context.Context, *ActivationDRMHandshakeRequest) (*ActivationDRMHandshakeResponse, error)
	ActivationDRMHandshakeInfo(context.Context, *ActivationDRMHandshakeInfoRequest) (*ActivationDRMHandshakeInfoResponse, error)
	ADIStartProvisioning(context.Context, *ADIStartProvisioningRequest) (*ADIStartProvisioningResponse, error)
	ADIEndProvisioning(context.Context, *ADIEndProvisioningRequest) (*ADIEndProvisioningResponse, error)
	AbsintheHello(context.Context, *AbsintheHelloRequest) (*AbsintheHelloResponse, error)
	AbsintheAddOption(context.Context, *AbsintheAddOptionRequest) (*AbsintheAddOptionResponse, error)
	AbsintheAtivateSession(context.Context, *AbsintheAtivateSessionRequest) (*AbsintheAtivateSessionResponse, error)
	AbsintheSignData(context.Context, *AbsintheSignDataRequest) (*AbsintheSignDataResponse, error)
	IndentitySession(context.Context, *IndentitySessionRequest) (*IndentitySessionResponse, error)
	IndentityValidation(context.Context, *IndentityValidationRequest) (*IndentityValidationResponse, error)
	mustEmbedUnimplementedCryptServiceServer()
}

// UnimplementedCryptServiceServer must be embedded to have forward compatible implementations.
type UnimplementedCryptServiceServer struct {
}

func (UnimplementedCryptServiceServer) Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}
func (UnimplementedCryptServiceServer) Finalize(context.Context, *FinalizeRequest) (*FinalizeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Finalize not implemented")
}
func (UnimplementedCryptServiceServer) Activation(context.Context, *ActivationRequest) (*ActivationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Activation not implemented")
}
func (UnimplementedCryptServiceServer) ActivationKeyData(context.Context, *ActivationKeyDataRequest) (*ActivationKeyDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivationKeyData not implemented")
}
func (UnimplementedCryptServiceServer) ActivationDRMHandshake(context.Context, *ActivationDRMHandshakeRequest) (*ActivationDRMHandshakeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivationDRMHandshake not implemented")
}
func (UnimplementedCryptServiceServer) ActivationDRMHandshakeInfo(context.Context, *ActivationDRMHandshakeInfoRequest) (*ActivationDRMHandshakeInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActivationDRMHandshakeInfo not implemented")
}
func (UnimplementedCryptServiceServer) ADIStartProvisioning(context.Context, *ADIStartProvisioningRequest) (*ADIStartProvisioningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ADIStartProvisioning not implemented")
}
func (UnimplementedCryptServiceServer) ADIEndProvisioning(context.Context, *ADIEndProvisioningRequest) (*ADIEndProvisioningResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ADIEndProvisioning not implemented")
}
func (UnimplementedCryptServiceServer) AbsintheHello(context.Context, *AbsintheHelloRequest) (*AbsintheHelloResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbsintheHello not implemented")
}
func (UnimplementedCryptServiceServer) AbsintheAddOption(context.Context, *AbsintheAddOptionRequest) (*AbsintheAddOptionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbsintheAddOption not implemented")
}
func (UnimplementedCryptServiceServer) AbsintheAtivateSession(context.Context, *AbsintheAtivateSessionRequest) (*AbsintheAtivateSessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbsintheAtivateSession not implemented")
}
func (UnimplementedCryptServiceServer) AbsintheSignData(context.Context, *AbsintheSignDataRequest) (*AbsintheSignDataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbsintheSignData not implemented")
}
func (UnimplementedCryptServiceServer) IndentitySession(context.Context, *IndentitySessionRequest) (*IndentitySessionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndentitySession not implemented")
}
func (UnimplementedCryptServiceServer) IndentityValidation(context.Context, *IndentityValidationRequest) (*IndentityValidationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IndentityValidation not implemented")
}
func (UnimplementedCryptServiceServer) mustEmbedUnimplementedCryptServiceServer() {}

// UnsafeCryptServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CryptServiceServer will
// result in compilation errors.
type UnsafeCryptServiceServer interface {
	mustEmbedUnimplementedCryptServiceServer()
}

func RegisterCryptServiceServer(s grpc.ServiceRegistrar, srv CryptServiceServer) {
	s.RegisterService(&CryptService_ServiceDesc, srv)
}

func _CryptService_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_Finalize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FinalizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).Finalize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/Finalize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).Finalize(ctx, req.(*FinalizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_Activation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).Activation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/Activation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).Activation(ctx, req.(*ActivationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_ActivationKeyData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivationKeyDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).ActivationKeyData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/ActivationKeyData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).ActivationKeyData(ctx, req.(*ActivationKeyDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_ActivationDRMHandshake_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivationDRMHandshakeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).ActivationDRMHandshake(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/ActivationDRMHandshake",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).ActivationDRMHandshake(ctx, req.(*ActivationDRMHandshakeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_ActivationDRMHandshakeInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActivationDRMHandshakeInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).ActivationDRMHandshakeInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/ActivationDRMHandshakeInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).ActivationDRMHandshakeInfo(ctx, req.(*ActivationDRMHandshakeInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_ADIStartProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ADIStartProvisioningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).ADIStartProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/ADIStartProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).ADIStartProvisioning(ctx, req.(*ADIStartProvisioningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_ADIEndProvisioning_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ADIEndProvisioningRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).ADIEndProvisioning(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/ADIEndProvisioning",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).ADIEndProvisioning(ctx, req.(*ADIEndProvisioningRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_AbsintheHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbsintheHelloRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).AbsintheHello(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/AbsintheHello",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).AbsintheHello(ctx, req.(*AbsintheHelloRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_AbsintheAddOption_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbsintheAddOptionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).AbsintheAddOption(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/AbsintheAddOption",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).AbsintheAddOption(ctx, req.(*AbsintheAddOptionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_AbsintheAtivateSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbsintheAtivateSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).AbsintheAtivateSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/AbsintheAtivateSession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).AbsintheAtivateSession(ctx, req.(*AbsintheAtivateSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_AbsintheSignData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbsintheSignDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).AbsintheSignData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/AbsintheSignData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).AbsintheSignData(ctx, req.(*AbsintheSignDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_IndentitySession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndentitySessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).IndentitySession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/IndentitySession",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).IndentitySession(ctx, req.(*IndentitySessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CryptService_IndentityValidation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndentityValidationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CryptServiceServer).IndentityValidation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/icrypto.CryptService/IndentityValidation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CryptServiceServer).IndentityValidation(ctx, req.(*IndentityValidationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CryptService_ServiceDesc is the grpc.ServiceDesc for CryptService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CryptService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "icrypto.CryptService",
	HandlerType: (*CryptServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Initialize",
			Handler:    _CryptService_Initialize_Handler,
		},
		{
			MethodName: "Finalize",
			Handler:    _CryptService_Finalize_Handler,
		},
		{
			MethodName: "Activation",
			Handler:    _CryptService_Activation_Handler,
		},
		{
			MethodName: "ActivationKeyData",
			Handler:    _CryptService_ActivationKeyData_Handler,
		},
		{
			MethodName: "ActivationDRMHandshake",
			Handler:    _CryptService_ActivationDRMHandshake_Handler,
		},
		{
			MethodName: "ActivationDRMHandshakeInfo",
			Handler:    _CryptService_ActivationDRMHandshakeInfo_Handler,
		},
		{
			MethodName: "ADIStartProvisioning",
			Handler:    _CryptService_ADIStartProvisioning_Handler,
		},
		{
			MethodName: "ADIEndProvisioning",
			Handler:    _CryptService_ADIEndProvisioning_Handler,
		},
		{
			MethodName: "AbsintheHello",
			Handler:    _CryptService_AbsintheHello_Handler,
		},
		{
			MethodName: "AbsintheAddOption",
			Handler:    _CryptService_AbsintheAddOption_Handler,
		},
		{
			MethodName: "AbsintheAtivateSession",
			Handler:    _CryptService_AbsintheAtivateSession_Handler,
		},
		{
			MethodName: "AbsintheSignData",
			Handler:    _CryptService_AbsintheSignData_Handler,
		},
		{
			MethodName: "IndentitySession",
			Handler:    _CryptService_IndentitySession_Handler,
		},
		{
			MethodName: "IndentityValidation",
			Handler:    _CryptService_IndentityValidation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "crypto.proto",
}
